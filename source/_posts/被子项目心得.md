---
title: 被子项目心得
date: 2020-01-20 18:27:37
tags:
    - quilt
categories: 
    - project-quilt
---
## 关于写文章页面的实现和编辑页面的渲染
### 写文章部分的实现
### 写文章部分难点主要是关联查询。
- 要将这篇文章所勾选的标签和分类一并提交至数据库（即批量插入标签和分类，故mapper部分还涉及到动态SQL语句），这就涉及到了一对多的问题。
- 为此，首先在建表阶段，要建立一个文章标签关联表和文章分类关联表。
- 在各自关联对象的DAO层，需要添加一个批量插入的接口。然后去mapper文件里使用动态SQL语句（也就是对插入的值进行一个foreach循环）来实现。
 - 其次，要解决的问题是，提交文章后，按照逻辑来讲应该按照数据库里这个文章的ID，创建关联对象，然后再插入标签和分类。怎么得到这个文章的ID呢？在文章插入的mapper实现方法处添加keyProperty这个属性，用来获得插入成功后获得的主键然后设useGeneratedKeys为true，标识主键自增。（注意这两个属性只能在insert和update里面用。）
 - 但是插入添加了这个字段以后，返回值还是影响的条数，但是可以通过这个对象得到插入成功后的ID。
 - 在业务逻辑层，首先将除标签和分类之外，文章表里有的字段信息进行插入，如果插入成功，返回值为1，且categoryId或者tagId不为空，那么再继续插入标签和分类。
 - 创建一个关联对象的List，然后循环对其中的每一个关联对象进行插入设置。*在循环体里创建关联对象*（标签和分类类似）
- 然后将这个list批量插入到表里。
     插入文章的时候只涉及了文章表和关联表，并不涉及具体的标签表和分类表。
- 最后controller层，先把标签和分类信息渲染出来，然后接受所有前台传递过来的信息，新建一个文章对象进行接受，将这些信息注入后，调用service层写的插入文章方法，返回值为1，则成功。
## 前台JSP页面
首先先对标签和分类进行循环输出（El表达式）
然后对回调函数的输出进行简单修改。

- 写文章部分还有一个图片上传的难点功能
更改文章处同步虽整个资料进行提交，文章编写处，需要用异步实现，且给用户返回一个地址。
 既然有文件上传，先写一个工具类fileuploadutils（工具类，静态成员变量，静态方法）另外注意文件上传是MultipartFile格式。
1. 先用SimpleDateFormat指定日期格式。
2. 先写关于个人简介处的图片上传。

1. 首先是指定文件保存的路径（这里根据当前日期的年月日保存，便于查找）
```
String path = "/static/upload/" + dateFormat.format(new Date());
```

2. 第二步是将整个自己自定义的路径，转换成编译后运行的路径。
>String realPath = session.getServletContext().getRealPath(path);

（注意系统实际运行的路径，和自己所编写的路径，是不太一样的，这里要将图片根据运行路径存储，才能访问到。如果直接按路径保存，是访问不到的。 getRealPath()的意义。）

3. 第三步是指定这个图片保存到服务器的名字。（UUID加它原来的名字）
>String fileName = UUID.randomUUID() + "_" + file.getOriginalFilename();
4. 第四步，根据它这个realPath,和新的fileName,创建一个新的文件对象saveFile。
5. 第五步判判断一下这个saveFile的父文件夹是否存在，不存在的话要创建mkdirs().
> if (!saveFile.getParentFile().exists()){
saveFile.getParentFile().mkdirs();}
这里不能直接判断!saveFile.exists(),例如一个目录为F:/static/upload/1.jpg
saveFile 仅是1.jpg，getParentFile是F:/static/upload/

6. 存在，保存。
>file.transferTo(saveFile);

## 关于修改文章
对该文章对应的标签，分类的渲染是一个有些复杂的过程，需要根据这个文章ID，得到对应的关联对象，再遍历这个关联对象表，得到每个对应的标签ID或者分类ID，再进行标签或者分类的查询。

## 关于分类目录的实现及渲染
- 关于分类，可以有父分类，且一个父分类对应多个子分类。这里使用了一张分类表，增加了一个PID的字段，规定父分类的PID为0 ，其对应子分类的PID为其父分类的ID。
- 在service层，页面渲染时需要用到获取所有父标签和子标签的方法，添加标签涉及到插入功能，编辑功能类似于标签，还需要有个获取特定分类的方法，最后删除功能，删除子分类时正常删除即可，删除父分类，要删除它下面的所有子分类。（所以还需要在dao层加一个删除所以子标签的接口 【删除所有PID=ID的记录】）

### 关于后台所有文章及首页的渲染
1. 编写接口：
- 根据文章ID/分类ID/标签ID 均可以获得和删除关联。
- 然后写对应的service。
- 这里删除父类节点时，如果有子节点，就不允许删除。
- 根据父节点获取子节点，然后如果子节点不为0，不允许删除。否则先删除关联，再删除此分类。
2. 关于获得文章信息（这里用Article对象就OK）
写获得文章信息时，需要自定义一个接口，mapper文件处自定义查询字段。
3. 还需要再在service层实现根据文章ID获取所对应的标签/分类。
 先创建一个关联对象的list
 再创建一个tag对象的list
 将关联对象循环，拿到每一个在关联表里面对应的tagid
 根据拿到的这个tagid,去标签表里面查找，返回一个tag对象
 将这个tag对象添加到tag对象的list里面 taglist.add(tag)
4. 怎样在前台输出每条记录呢？这里用到了POJO包装类。
 在dto包里面建立一个包含了文章对象，标签列表，分类列表的包装类。（因为一个文章对应多个标签或者分类）
5. 在controller层，首先建立一个文章list得到所有文章，然后再建立一个包装对象的List,遍历文章的list,为每一个文章注入它所对应的标签和分类（调用service层根据文章ID获取分类和标签的方法，获得所有对应的标签和分类存到一个组里面，然后新建一个包装对象来接受，接受后将此对象添加到list里面），最后通过model，把包装对象的list渲染到前台页面。
6. 前台页面渲染时，关于时间的显示，需要按照更新时间倒序排列。
`<fmt:formatDate value="${articleListDto.article.createTime}" 
pattern="yyyy-MM-dd HH:mm:ss" />`
7. 删除功能，需要先删除和文章，分类的关联，然后删除此文章。
8. 修改功能，点击修改按钮，进入一个类似于写文章的页面，但是需要渲染，将本文章原有信息渲染成默认值。这里的难点还是对于标签和分类的渲染。先得到用户选择的所有标签和分类的list，然后在前台通过script代码，得到每一个标签的ID。
```
var tagList = new Array();
var categoryList = new Array();
<c:forEach items="${tags}" var="tag">
tagList.push(${tag.id});
</c:forEach>
<C:forEach items="${categories}" var="category">
categoryList.push(${category.id});
</C:forEach>
for (var i = 0; i < tagList.length ; i++) {
$('input[value=' + tagList[i] + '][name="articleTagId"]').attr("checked","checked");}
for (var i = 0; i < categoryList.length ; i++) {
$('input[value=' + categoryList[i] + '][name="articleCategoryId"]').attr("checked","checked");}
```

3.修改方法的具体实现类似于写文章的功能。
   关于后台首页的渲染，需要再增加一个接口，根据时间倒序排列，得到最新的八条记录，以此降低数据库的查询压力。

4.关于前台首页的渲染及分页搜索等功能的实现
- 前台文章的显示需规定只显示前500个字符
```
${fn:substring(articleWithBLOBsDto.articleWithBLOBs.htmlContent, 0, 500)}
```
- 关于搜索文章，可实现输入一个字符就动态搜索一次
```
<input class="local-search-box--input" placeholder="搜索文章" onkeyup="searchWord(this)">
function searchWord(obj) {
    //1、获得输入框的输入的内容
    var word = $(obj).val();
    //2、根据输入框的内容去数据库中模糊查询---List<Product>
    var content = "";
    $.post(
        "<%=request.getContextPath()%>/search", {
            title: word
        },
        function (result) {
            if (result.data.length > 0) {
                for (var i = 0; i < result.data.length; i++) {
                    content += '<div class="search-result-lis " onclick=' + clickFn(this) +
                        'onmouseover=' + overFn(this) + ' onmouseout=' + outFn(this) +
                        '><div class="local-search__hit-item">
<a href=<%=request.getContextPath()%>/detail/' + result.data[i].id
                             + ' class="search-result-title">  ' 
+ result.data[i].title + '</a></div>';}
                $("#display").html(content);
                $("#display").css("display", "block");
            }else {
                $("#display").css("display", "none");} },
        "json"
    );
    if (obj.value.length == 0) { 
//判断输入框是否为空，如果为空则隐藏提示区域
        console.log("111");
        $("#display").css("display", "none");
    }}
```

## 关于文章的分页
1.首先需要创建一个类似于包装类的pagedResult
```
private List<T> dataList;//数据
private long pageNo;//当前页
private long pageSize;//条数
private long total;//总条数
private long pages;//总页面数目
```
2.其次要对Controller进行修改
```
List<ArticleWithBLOBsDto> articleWithBLOBsDtoList = 
new ArrayList<ArticleWithBLOBsDto>();
PagedResult<ArticleWithBLOBs> pagedResult = 
articleService.getArticlePage(pageNo,2);
for (ArticleWithBLOBs articleWithBLOBs : pagedResult.getDataList()){
    List<Category> categoryList = 
categoryService.getCategoryListByArticleId(articleWithBLOBs.getId());
    List<Tag> tagList = 
tagService.getTagListByArticleId(articleWithBLOBs.getId());
    ArticleWithBLOBsDto articleWithBLOBsDto = 
new ArticleWithBLOBsDto(articleWithBLOBs,tagList,categoryList);
    articleWithBLOBsDtoList.add(articleWithBLOBsDto);
}
model.addAttribute("pagedResult",pagedResult);
model.addAttribute("articleWithBLOBsDtoList",articleWithBLOBsDtoList);
```
3.最后到前台需要有个逻辑判断
```
<c:choose>
    <c:when test="${pagedResult.pageNo == 1 && pagedResult.pages == 1}">
        <span class="page-number current">${pagedResult.pageNo}</span>
    </c:when>
    <c:when test="${pagedResult.pageNo == 1 && pagedResult.pages >1 }">
        <span class="page-number current">${pagedResult.pageNo}</span>
        <a class="page-number" 
href="<%=request.getContextPath()%>/${pagedResult.pageNo+1}"> >> </a>
    </c:when>
    <c:when test="${pagedResult.pageNo != 1 
&& pagedResult.pageNo != pagedResult.pages }">
        <a class="page-number" 
href="<%=request.getContextPath()%>/${pagedResult.pageNo-1}"> << </a>
        <span class="page-number current">${pagedResult.pageNo}</span>
        <a class="page-number" 
href="<%=request.getContextPath()%>/${pagedResult.pageNo+1}"> >> </a>
    </c:when>
    <c:when test="${pagedResult.pageNo !=1 
&& pagedResult.pageNo == pagedResult.pages}">
        <a class="page-number" 
href="<%=request.getContextPath()%>/${pagedResult.pageNo-1}"> << </a>
        <span class="page-number current">${pagedResult.pageNo}</span>
    </c:when>
</c:choose>
```

## 关于文章详情页处标题的提取与跳转
  1.标题的提取需要引入一个Jsoup的jar包，根据h1标题提取。
```
 public static List<Chapter> handleChapeter(String htmlContent){
    Document document = Jsoup.parse(htmlContent);
    Elements elements = document.getElementsByTag("h1");
    int i=1 ;
    List<Chapter> chapterList = new ArrayList<Chapter>();
    for (Element element : elements){
        String chapterName = element.text();
        String chapterId = element.attr("id");
        Chapter chapter = new Chapter(chapterId,i,chapterName);
        i++;
        chapterList.add(chapter);}
    return chapterList;
}
```
2.在前台页面的渲染处，在侧边栏显示提取到的标题
```
<c:forEach items="${chapterList}" var="chapter">
   <li class="toc-item toc-level-2">
<a class="toc-link" href="#${chapter.chapterId}">
<span class="toc-number">${chapter.chapterNum}.</span>
 <span class="toc-text">${chapter.chapterName}</span></a>
    </li>
</c:forEach>
```