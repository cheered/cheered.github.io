---
title: 机试知识点
date: 2020-03-18 12:21:40
tags: 
    - 机试 
    - Markdown
categories:
    - 机试知识点
---

## 排序 - sort函数
- 用法：sort（排序起始地址，排序结束地址，比较函数）；
- eg: sort(buf,buf+n,cmp);
- 头文件中的设置：
```
    #include<algorithm>
    using namespace std;
```
- 或者定义在结构体中（重载运算符）
```
    struct E{
        char name[101];
        int age;
        int score;
        bool operator < (const E &b)const{
            if(score!=b.score) return score<b.score;
        }
    }buf[1000];

    sort(buf,buf+n);
```

## 日期处理
- 求两个日期的天数差，可以把原区间问题，统一到起点确定的区间问题上去。
- 起点可以是0年1月1日
- 日期问题特别要注意的闰年：
```
    x%100!=0 && x%4 ==0 || x%400==0 ? 1 : 0
```
- 年月日 可以使用三维数组（hash的思想）
- 输入时如果是“20220321”的格式 可以用scanf("%4d%2d%2d") 分别赋值。
- 自定义数组 dayOfMonth[13][2]  把平年闰年每个月分别有几天对应进去

## Hash应用
- 存储位置和数据本身对应起来的存储手段。

## 二分查找
```
    int base=0,top=size;
    while（top>=base){
        int mid=(top+base)/2;
        if(buf[mid]<target) base=mid+1;
        else top=mid-1;
    }
    int ans=top;
```

## 栈的应用（字符串匹配，运算器的实现）
- 特点：后进先出
- 定义：stack<int> s;
- 头文件需要预处理： #include<stack>
- 使用： s.push(i); 向栈内压入一个元素
        int x=s.top(); 读取栈顶元素，将其值赋予变量x + s.pop();弹出栈顶元素
### 对于运算器的实现
- 设置两个栈，一个保存运算符 一个保存数字
- 从左到右遍历字符串，若遍历到运算符，则将其与运算符栈顶元素进行比较，若栈顶的优先级小于当前的或者此时运算符栈为空，则将该运算符压栈。
- 若大于，弹出栈顶运算符，再从数字栈中依次弹出两个数字，得到结果后将结果压入数字栈，重复比较此时栈顶运算符与当前遍历到的运算符优先级 ，重复上述步骤。
- 若遍历到数字，则直接压入数字栈。
- 若运算符堆栈中仅存有两个运算符且栈顶元素为我们人为添加的标记运算符，运算结束，数字栈中唯一的数字就是我们要求的值。
```
    int mat[][5]={
        1,0,0,0,0,
        1,0,0,0,0,
        1,0,0,0,0,
        1,1,1,0,0,
        1,1,1,0,0,
    };  
    若mat[i][j]==1 则表示i号运算符优先级大于j号运算符 +1 -2 *3 /4
```

```
    void getOp(bool &reto,int &retn,int &i){
        //获得表达式中下一个元素函数
        //若函数运行结束时，
        //引用变量reto为true,则表示该元素为一个运算符，编号保存在retn中
        //否则该元素为一个数字，其值保存在引用变量retn中，
        //引用变量i表示遍历到的字符串下标
        if( i==0 && op.empty()){
            //遍历第一个字符且运算符栈为空,人工添加编号为0的标记字符
            reto=true;
            retn=0;
            return;
        }
        if(str[i]==0){
            //遍历字符串为空字符，表示字符串已经被遍历完
            reto=true;
            retn=0;
            return;
        }
        if(str[i]>='0'&&str[i]<='9'){
            reto=false;
        }
        else{
            reto=true;
            if(str[i]=='+')  retn=1;
            else if(str[i]=='-')  retn=2;
            else if(str[i]=='*')  retn=3;
            else if(srr[i]=='/')  retn=4;
        }
        i+=2; //i递增，跳过该运算符和运算符后面的空格
        return;
    }
```

## 二叉树
### 根据前序和中序遍历还原树
```
    int ioc; //静态数组中已经分配的结点个数
    Node *creat(){
        Tree[ioc].lchlid=Tree[ioc].rchild=NULL;
        return &Tree[ioc++];
    }
    Node *build(int s1,int e1,int s2,int e2){
        Node *ret=creat();
        ret->c=str1[s1];
        int rootidx;
        for(int i=s2;i<=e2;i++){
            if(str2[i]==str1[s1]){
                rootidx=i;break;
            }
        }
        if(rootidx!=s2)
            ret->lchild=build(s1+1,s1+(rootidx-s2),s2,rootidx-1);
        if(rootidx!=e2)
            ret->rchild=build(s1+(rootidx-s2)+1,e2,rootidx+1,e2);
        return ret;
    }
```

## %运算符
- a%b a,b必须是整型变量 不能是浮点数，b变量必须是非零值

##  进制转换

## 最大公约数
```
    int gcd(int a,int b){
        while(b!=0){
            int t=a%b;
            a=b;
            b=t;
        }
        return a;
    }
```

## 最小公倍数
```
    int gcd(int a,int b){
        return b!=0 ? gcd(b,a%b) : a ;
    }
    a*b/gcd(a,b);
```

## 素数判定
```
    bool judge(int x){
        if(x<=1)  return false;
        int bound=(int)sqrt(x)+1;
        for(int i=2;i<bound;i++){
            if(x%i==0)
                return false;
        }
        return true;
    }
```

## 二分求幂 A的B次方
```
    while(scanf("%d%d",&a,&b)!=EOF){
        if(a==0&&b==0) break;
        int ans=1;  //保存最终结果变量
        while(b!=0){
            if(b%2==1){ //当前二进制位为1累乘a的2^k次至变量ans
                ans*=a; //最终结果累乘a
                ans%=1000;  //求其后三位数
            }
            b/=2;
            a*=a; //求下一位二进制位权重
            a%=1000;
        }
        printf("%d\n",ans); //输出结果
    }
```